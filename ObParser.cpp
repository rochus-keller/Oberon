// This file was automatically generated by EbnfStudio; don't modify it!
#include "ObParser.h"
using namespace Ob;

static inline bool FIRST_Oberon(int tt) {
	return tt == Tok_MODULE || tt == Tok_DEFINITION;
}

static inline bool FIRST_number(int tt) {
	return tt == Tok_real || tt == Tok_integer;
}

static inline bool FIRST_qualident(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_identdef(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_ConstDeclaration(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_ConstExpression(int tt) {
	switch(tt){
	case Tok_FALSE:
	case Tok_real:
	case Tok_Plus:
	case Tok_Lbrace:
	case Tok_integer:
	case Tok_ident:
	case Tok_hexchar:
	case Tok_Tilde:
	case Tok_string:
	case Tok_NIL:
	case Tok_TRUE:
	case Tok_Minus:
	case Tok_Lpar:
	case Tok_hexstring:
		return true;
	default: return false;
	}
}

static inline bool FIRST_TypeDeclaration(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_type(int tt) {
	return tt == Tok_POINTER || tt == Tok_ARRAY || tt == Tok_ident || tt == Tok_PROCEDURE || tt == Tok_RECORD;
}

static inline bool FIRST_NamedType(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_ArrayType(int tt) {
	return tt == Tok_ARRAY;
}

static inline bool FIRST_LengthList(int tt) {
	switch(tt){
	case Tok_FALSE:
	case Tok_real:
	case Tok_Plus:
	case Tok_Lbrace:
	case Tok_integer:
	case Tok_ident:
	case Tok_hexchar:
	case Tok_Tilde:
	case Tok_string:
	case Tok_NIL:
	case Tok_TRUE:
	case Tok_Minus:
	case Tok_Lpar:
	case Tok_hexstring:
		return true;
	default: return false;
	}
}

static inline bool FIRST_length(int tt) {
	switch(tt){
	case Tok_FALSE:
	case Tok_real:
	case Tok_Plus:
	case Tok_Lbrace:
	case Tok_integer:
	case Tok_ident:
	case Tok_hexchar:
	case Tok_Tilde:
	case Tok_string:
	case Tok_NIL:
	case Tok_TRUE:
	case Tok_Minus:
	case Tok_Lpar:
	case Tok_hexstring:
		return true;
	default: return false;
	}
}

static inline bool FIRST_RecordType(int tt) {
	return tt == Tok_RECORD;
}

static inline bool FIRST_BaseType(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_FieldListSequence(int tt) {
	return tt == Tok_WEAK || tt == Tok_ident;
}

static inline bool FIRST_FieldList(int tt) {
	return tt == Tok_WEAK || tt == Tok_ident;
}

static inline bool FIRST_IdentList(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_PointerType(int tt) {
	return tt == Tok_POINTER;
}

static inline bool FIRST_ProcedureType(int tt) {
	return tt == Tok_PROCEDURE;
}

static inline bool FIRST_VariableDeclaration(int tt) {
	return tt == Tok_WEAK || tt == Tok_ident;
}

static inline bool FIRST_designator(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_selector(int tt) {
	return tt == Tok_Lbrack || tt == Tok_Hat || tt == Tok_Lpar || tt == Tok_Dot;
}

static inline bool FIRST_ExpList(int tt) {
	switch(tt){
	case Tok_FALSE:
	case Tok_real:
	case Tok_Plus:
	case Tok_Lbrace:
	case Tok_integer:
	case Tok_ident:
	case Tok_hexchar:
	case Tok_Tilde:
	case Tok_string:
	case Tok_NIL:
	case Tok_TRUE:
	case Tok_Minus:
	case Tok_Lpar:
	case Tok_hexstring:
		return true;
	default: return false;
	}
}

static inline bool FIRST_expression(int tt) {
	switch(tt){
	case Tok_FALSE:
	case Tok_real:
	case Tok_Plus:
	case Tok_Lbrace:
	case Tok_integer:
	case Tok_ident:
	case Tok_hexchar:
	case Tok_Tilde:
	case Tok_string:
	case Tok_NIL:
	case Tok_TRUE:
	case Tok_Minus:
	case Tok_Lpar:
	case Tok_hexstring:
		return true;
	default: return false;
	}
}

static inline bool FIRST_relation(int tt) {
	switch(tt){
	case Tok_Leq:
	case Tok_Gt:
	case Tok_IS:
	case Tok_Eq:
	case Tok_IN:
	case Tok_Hash:
	case Tok_Geq:
	case Tok_Lt:
		return true;
	default: return false;
	}
}

static inline bool FIRST_SimpleExpression(int tt) {
	switch(tt){
	case Tok_FALSE:
	case Tok_real:
	case Tok_Plus:
	case Tok_Lbrace:
	case Tok_integer:
	case Tok_ident:
	case Tok_hexchar:
	case Tok_Tilde:
	case Tok_string:
	case Tok_NIL:
	case Tok_TRUE:
	case Tok_Minus:
	case Tok_Lpar:
	case Tok_hexstring:
		return true;
	default: return false;
	}
}

static inline bool FIRST_AddOperator(int tt) {
	return tt == Tok_Plus || tt == Tok_OR || tt == Tok_Minus;
}

static inline bool FIRST_term(int tt) {
	switch(tt){
	case Tok_FALSE:
	case Tok_real:
	case Tok_Lbrace:
	case Tok_integer:
	case Tok_ident:
	case Tok_hexchar:
	case Tok_Tilde:
	case Tok_string:
	case Tok_NIL:
	case Tok_TRUE:
	case Tok_Lpar:
	case Tok_hexstring:
		return true;
	default: return false;
	}
}

static inline bool FIRST_MulOperator(int tt) {
	return tt == Tok_Star || tt == Tok_DIV || tt == Tok_Amp || tt == Tok_MOD || tt == Tok_Slash;
}

static inline bool FIRST_literal(int tt) {
	switch(tt){
	case Tok_FALSE:
	case Tok_real:
	case Tok_Lbrace:
	case Tok_integer:
	case Tok_hexchar:
	case Tok_string:
	case Tok_NIL:
	case Tok_TRUE:
	case Tok_hexstring:
		return true;
	default: return false;
	}
}

static inline bool FIRST_factor(int tt) {
	switch(tt){
	case Tok_FALSE:
	case Tok_real:
	case Tok_Lbrace:
	case Tok_integer:
	case Tok_ident:
	case Tok_hexchar:
	case Tok_Tilde:
	case Tok_string:
	case Tok_NIL:
	case Tok_TRUE:
	case Tok_Lpar:
	case Tok_hexstring:
		return true;
	default: return false;
	}
}

static inline bool FIRST_variableOrFunctionCall(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_set(int tt) {
	return tt == Tok_Lbrace;
}

static inline bool FIRST_element(int tt) {
	switch(tt){
	case Tok_FALSE:
	case Tok_real:
	case Tok_Plus:
	case Tok_Lbrace:
	case Tok_integer:
	case Tok_ident:
	case Tok_hexchar:
	case Tok_Tilde:
	case Tok_string:
	case Tok_NIL:
	case Tok_TRUE:
	case Tok_Minus:
	case Tok_Lpar:
	case Tok_hexstring:
		return true;
	default: return false;
	}
}

static inline bool FIRST_statement(int tt) {
	switch(tt){
	case Tok_CASE:
	case Tok_LOOP:
	case Tok_IF:
	case Tok_FOR:
	case Tok_ident:
	case Tok_RETURN:
	case Tok_WHILE:
	case Tok_EXIT:
	case Tok_WITH:
	case Tok_REPEAT:
		return true;
	default: return false;
	}
}

static inline bool FIRST_assignmentOrProcedureCall(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_StatementSequence(int tt) {
	switch(tt){
	case Tok_Semi:
	case Tok_CASE:
	case Tok_LOOP:
	case Tok_IF:
	case Tok_FOR:
	case Tok_ident:
	case Tok_RETURN:
	case Tok_WHILE:
	case Tok_EXIT:
	case Tok_WITH:
	case Tok_REPEAT:
		return true;
	default: return false;
	}
}

static inline bool FIRST_IfStatement(int tt) {
	return tt == Tok_IF;
}

static inline bool FIRST_ElsifStatement(int tt) {
	return tt == Tok_ELSIF;
}

static inline bool FIRST_ElseStatement(int tt) {
	return tt == Tok_ELSE;
}

static inline bool FIRST_CaseStatement(int tt) {
	return tt == Tok_CASE;
}

static inline bool FIRST_Case(int tt) {
	switch(tt){
	case Tok_FALSE:
	case Tok_real:
	case Tok_Plus:
	case Tok_Lbrace:
	case Tok_integer:
	case Tok_ident:
	case Tok_hexchar:
	case Tok_Tilde:
	case Tok_string:
	case Tok_NIL:
	case Tok_TRUE:
	case Tok_Minus:
	case Tok_Lpar:
	case Tok_hexstring:
		return true;
	default: return false;
	}
}

static inline bool FIRST_CaseLabelList(int tt) {
	switch(tt){
	case Tok_FALSE:
	case Tok_real:
	case Tok_Plus:
	case Tok_Lbrace:
	case Tok_integer:
	case Tok_ident:
	case Tok_hexchar:
	case Tok_Tilde:
	case Tok_string:
	case Tok_NIL:
	case Tok_TRUE:
	case Tok_Minus:
	case Tok_Lpar:
	case Tok_hexstring:
		return true;
	default: return false;
	}
}

static inline bool FIRST_LabelRange(int tt) {
	switch(tt){
	case Tok_FALSE:
	case Tok_real:
	case Tok_Plus:
	case Tok_Lbrace:
	case Tok_integer:
	case Tok_ident:
	case Tok_hexchar:
	case Tok_Tilde:
	case Tok_string:
	case Tok_NIL:
	case Tok_TRUE:
	case Tok_Minus:
	case Tok_Lpar:
	case Tok_hexstring:
		return true;
	default: return false;
	}
}

static inline bool FIRST_label(int tt) {
	switch(tt){
	case Tok_FALSE:
	case Tok_real:
	case Tok_Plus:
	case Tok_Lbrace:
	case Tok_integer:
	case Tok_ident:
	case Tok_hexchar:
	case Tok_Tilde:
	case Tok_string:
	case Tok_NIL:
	case Tok_TRUE:
	case Tok_Minus:
	case Tok_Lpar:
	case Tok_hexstring:
		return true;
	default: return false;
	}
}

static inline bool FIRST_WhileStatement(int tt) {
	return tt == Tok_WHILE;
}

static inline bool FIRST_ElsifStatement2(int tt) {
	return tt == Tok_ELSIF;
}

static inline bool FIRST_RepeatStatement(int tt) {
	return tt == Tok_REPEAT;
}

static inline bool FIRST_ForStatement(int tt) {
	return tt == Tok_FOR;
}

static inline bool FIRST_WithStatement(int tt) {
	return tt == Tok_WITH;
}

static inline bool FIRST_Guard(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_LoopStatement(int tt) {
	return tt == Tok_LOOP;
}

static inline bool FIRST_ExitStatement(int tt) {
	return tt == Tok_EXIT;
}

static inline bool FIRST_ProcedureDeclaration(int tt) {
	return tt == Tok_PROC || tt == Tok_PROCEDURE;
}

static inline bool FIRST_ProcedureHeading(int tt) {
	return tt == Tok_PROC || tt == Tok_PROCEDURE;
}

static inline bool FIRST_Receiver(int tt) {
	return tt == Tok_Lpar;
}

static inline bool FIRST_ProcedureBody(int tt) {
	switch(tt){
	case Tok_PROC:
	case Tok_VAR:
	case Tok_END:
	case Tok_CONST:
	case Tok_DO:
	case Tok_RETURN:
	case Tok_PROCEDURE:
	case Tok_BEGIN:
	case Tok_TYPE:
		return true;
	default: return false;
	}
}

static inline bool FIRST_DeclarationSequence(int tt) {
	return tt == Tok_PROC || tt == Tok_VAR || tt == Tok_CONST || tt == Tok_PROCEDURE || tt == Tok_TYPE;
}

static inline bool FIRST_ReturnStatement(int tt) {
	return tt == Tok_RETURN;
}

static inline bool FIRST_DeclarationSequence2(int tt) {
	return tt == Tok_PROC || tt == Tok_VAR || tt == Tok_CONST || tt == Tok_PROCEDURE || tt == Tok_TYPE;
}

static inline bool FIRST_FormalParameters(int tt) {
	return tt == Tok_Lpar;
}

static inline bool FIRST_FPSection(int tt) {
	return tt == Tok_VAR || tt == Tok_ident;
}

static inline bool FIRST_FormalType(int tt) {
	return tt == Tok_POINTER || tt == Tok_ARRAY || tt == Tok_ident || tt == Tok_PROCEDURE || tt == Tok_RECORD;
}

static inline bool FIRST_module(int tt) {
	return tt == Tok_MODULE;
}

static inline bool FIRST_ImportList(int tt) {
	return tt == Tok_IMPORT;
}

static inline bool FIRST_import(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_definition(int tt) {
	return tt == Tok_DEFINITION;
}

void Parser::RunParser() {
	root = SynTree();
	errors.clear();
	next();
	Oberon(&root);
}

void Parser::next() {
	cur = la;
	la = scanner->next();
	while( la.d_type == Tok_Invalid ) {
		errors << Error(la.d_val, la.d_lineNr, la.d_colNr, la.d_sourcePath);
		la = scanner->next();
	}
}

Token Parser::peek(int off) {
	if( off == 1 )
		return la;
	else if( off == 0 )
		return cur;
	else
		return scanner->peek(off-1);
}

void Parser::invalid(const char* what) {
	errors << Error(QString("invalid %1").arg(what),la.d_lineNr, la.d_colNr, la.d_sourcePath);
}

bool Parser::expect(int tt, bool pkw, const char* where) {
	if( la.d_type == tt) { next(); return true; }
	else { errors << Error(QString("'%1' expected in %2").arg(tokenTypeString(tt)).arg(where),la.d_lineNr, la.d_colNr, la.d_sourcePath); return false; }
}

static inline void dummy() {}

	void Parser::addTerminal(SynTree* st) {
		if( cur.d_type != Tok_Semi && cur.d_type != Tok_Comma && cur.d_type != Tok_Dot && cur.d_type != Tok_Colon ){
			SynTree* tmp = new SynTree( cur ); st->d_children.append(tmp);
		}
	}
void Parser::Oberon(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Oberon, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_module(la.d_type) ) {
		module(st);
	} else if( FIRST_definition(la.d_type) ) {
		definition(st);
	} else
		invalid("Oberon");
}

void Parser::number(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_number, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_integer ) {
		if( expect(Tok_integer, false, "number") ) addTerminal(st);
	} else if( la.d_type == Tok_real ) {
		if( expect(Tok_real, false, "number") ) addTerminal(st);
	} else
		invalid("number");
}

void Parser::qualident(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_qualident, la); st->d_children.append(tmp); st = tmp; }
	if( ( peek(1).d_type == Tok_ident && peek(2).d_type == Tok_Dot )  ) {
		if( expect(Tok_ident, false, "qualident") ) addTerminal(st);
		if( expect(Tok_Dot, false, "qualident") ) addTerminal(st);
	}
	if( expect(Tok_ident, false, "qualident") ) addTerminal(st);
}

void Parser::identdef(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_identdef, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ident, false, "identdef") ) addTerminal(st);
	if( la.d_type == Tok_Star || la.d_type == Tok_Minus ) {
		if( la.d_type == Tok_Star ) {
			if( expect(Tok_Star, false, "identdef") ) addTerminal(st);
		} else if( la.d_type == Tok_Minus ) {
			if( expect(Tok_Minus, false, "identdef") ) addTerminal(st);
		} else
			invalid("identdef");
	}
}

void Parser::ConstDeclaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ConstDeclaration, la); st->d_children.append(tmp); st = tmp; }
	identdef(st);
	if( expect(Tok_Eq, false, "ConstDeclaration") ) addTerminal(st);
	ConstExpression(st);
}

void Parser::ConstExpression(SynTree* st) {
	expression(st);
}

void Parser::TypeDeclaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_TypeDeclaration, la); st->d_children.append(tmp); st = tmp; }
	identdef(st);
	if( expect(Tok_Eq, false, "TypeDeclaration") ) addTerminal(st);
	type(st);
}

void Parser::type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_type, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_NamedType(la.d_type) ) {
		NamedType(st);
	} else if( FIRST_ArrayType(la.d_type) ) {
		ArrayType(st);
	} else if( FIRST_RecordType(la.d_type) ) {
		RecordType(st);
	} else if( FIRST_PointerType(la.d_type) ) {
		PointerType(st);
	} else if( FIRST_ProcedureType(la.d_type) ) {
		ProcedureType(st);
	} else
		invalid("type");
}

void Parser::NamedType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_NamedType, la); st->d_children.append(tmp); st = tmp; }
	qualident(st);
}

void Parser::ArrayType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ArrayType, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ARRAY, false, "ArrayType") ) addTerminal(st);
	if( FIRST_LengthList(la.d_type) ) {
		LengthList(st);
	}
	if( expect(Tok_OF, false, "ArrayType") ) addTerminal(st);
	type(st);
}

void Parser::LengthList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_LengthList, la); st->d_children.append(tmp); st = tmp; }
	length(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "LengthList") ) addTerminal(st);
		length(st);
	}
}

void Parser::length(SynTree* st) {
	ConstExpression(st);
}

void Parser::RecordType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_RecordType, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_RECORD, false, "RecordType") ) addTerminal(st);
	if( la.d_type == Tok_Lpar ) {
		if( expect(Tok_Lpar, false, "RecordType") ) addTerminal(st);
		BaseType(st);
		if( expect(Tok_Rpar, false, "RecordType") ) addTerminal(st);
	}
	if( FIRST_FieldListSequence(la.d_type) ) {
		FieldListSequence(st);
	}
	if( expect(Tok_END, false, "RecordType") ) addTerminal(st);
}

void Parser::BaseType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_BaseType, la); st->d_children.append(tmp); st = tmp; }
	NamedType(st);
}

void Parser::FieldListSequence(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FieldListSequence, la); st->d_children.append(tmp); st = tmp; }
	FieldList(st);
	while( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "FieldListSequence") ) addTerminal(st);
		if( FIRST_FieldList(la.d_type) ) {
			FieldList(st);
		}
	}
}

void Parser::FieldList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FieldList, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_WEAK ) {
		if( expect(Tok_WEAK, false, "FieldList") ) addTerminal(st);
	}
	IdentList(st);
	if( expect(Tok_Colon, false, "FieldList") ) addTerminal(st);
	type(st);
}

void Parser::IdentList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_IdentList, la); st->d_children.append(tmp); st = tmp; }
	identdef(st);
	while( la.d_type == Tok_Comma || FIRST_identdef(la.d_type) ) {
		if( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "IdentList") ) addTerminal(st);
		}
		identdef(st);
	}
}

void Parser::PointerType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_PointerType, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_POINTER, false, "PointerType") ) addTerminal(st);
	if( expect(Tok_TO, false, "PointerType") ) addTerminal(st);
	type(st);
}

void Parser::ProcedureType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ProcedureType, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_PROCEDURE, false, "ProcedureType") ) addTerminal(st);
	if( FIRST_FormalParameters(la.d_type) ) {
		FormalParameters(st);
	}
}

void Parser::VariableDeclaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_VariableDeclaration, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_WEAK ) {
		if( expect(Tok_WEAK, false, "VariableDeclaration") ) addTerminal(st);
	}
	IdentList(st);
	if( expect(Tok_Colon, false, "VariableDeclaration") ) addTerminal(st);
	type(st);
}

void Parser::designator(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_designator, la); st->d_children.append(tmp); st = tmp; }
	qualident(st);
	while( FIRST_selector(la.d_type) ) {
		selector(st);
	}
}

void Parser::selector(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_selector, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Dot ) {
		if( expect(Tok_Dot, false, "selector") ) addTerminal(st);
		if( expect(Tok_ident, false, "selector") ) addTerminal(st);
	} else if( la.d_type == Tok_Lbrack ) {
		if( expect(Tok_Lbrack, false, "selector") ) addTerminal(st);
		ExpList(st);
		if( expect(Tok_Rbrack, false, "selector") ) addTerminal(st);
	} else if( la.d_type == Tok_Hat ) {
		if( expect(Tok_Hat, false, "selector") ) addTerminal(st);
	} else if( la.d_type == Tok_Lpar ) {
		if( expect(Tok_Lpar, false, "selector") ) addTerminal(st);
		if( FIRST_ExpList(la.d_type) ) {
			ExpList(st);
		}
		if( expect(Tok_Rpar, false, "selector") ) addTerminal(st);
	} else
		invalid("selector");
}

void Parser::ExpList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ExpList, la); st->d_children.append(tmp); st = tmp; }
	expression(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "ExpList") ) addTerminal(st);
		expression(st);
	}
}

void Parser::expression(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_expression, la); st->d_children.append(tmp); st = tmp; }
	SimpleExpression(st);
	if( FIRST_relation(la.d_type) ) {
		relation(st);
		SimpleExpression(st);
	}
}

void Parser::relation(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_relation, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Eq ) {
		if( expect(Tok_Eq, false, "relation") ) addTerminal(st);
	} else if( la.d_type == Tok_Hash ) {
		if( expect(Tok_Hash, false, "relation") ) addTerminal(st);
	} else if( la.d_type == Tok_Lt ) {
		if( expect(Tok_Lt, false, "relation") ) addTerminal(st);
	} else if( la.d_type == Tok_Leq ) {
		if( expect(Tok_Leq, false, "relation") ) addTerminal(st);
	} else if( la.d_type == Tok_Gt ) {
		if( expect(Tok_Gt, false, "relation") ) addTerminal(st);
	} else if( la.d_type == Tok_Geq ) {
		if( expect(Tok_Geq, false, "relation") ) addTerminal(st);
	} else if( la.d_type == Tok_IN ) {
		if( expect(Tok_IN, false, "relation") ) addTerminal(st);
	} else if( la.d_type == Tok_IS ) {
		if( expect(Tok_IS, false, "relation") ) addTerminal(st);
	} else
		invalid("relation");
}

void Parser::SimpleExpression(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_SimpleExpression, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Plus || la.d_type == Tok_Minus ) {
		if( la.d_type == Tok_Plus ) {
			if( expect(Tok_Plus, false, "SimpleExpression") ) addTerminal(st);
		} else if( la.d_type == Tok_Minus ) {
			if( expect(Tok_Minus, false, "SimpleExpression") ) addTerminal(st);
		} else
			invalid("SimpleExpression");
	}
	term(st);
	while( FIRST_AddOperator(la.d_type) ) {
		AddOperator(st);
		term(st);
	}
}

void Parser::AddOperator(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_AddOperator, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Plus ) {
		if( expect(Tok_Plus, false, "AddOperator") ) addTerminal(st);
	} else if( la.d_type == Tok_Minus ) {
		if( expect(Tok_Minus, false, "AddOperator") ) addTerminal(st);
	} else if( la.d_type == Tok_OR ) {
		if( expect(Tok_OR, false, "AddOperator") ) addTerminal(st);
	} else
		invalid("AddOperator");
}

void Parser::term(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_term, la); st->d_children.append(tmp); st = tmp; }
	factor(st);
	while( FIRST_MulOperator(la.d_type) ) {
		MulOperator(st);
		factor(st);
	}
}

void Parser::MulOperator(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_MulOperator, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Star ) {
		if( expect(Tok_Star, false, "MulOperator") ) addTerminal(st);
	} else if( la.d_type == Tok_Slash ) {
		if( expect(Tok_Slash, false, "MulOperator") ) addTerminal(st);
	} else if( la.d_type == Tok_DIV ) {
		if( expect(Tok_DIV, false, "MulOperator") ) addTerminal(st);
	} else if( la.d_type == Tok_MOD ) {
		if( expect(Tok_MOD, false, "MulOperator") ) addTerminal(st);
	} else if( la.d_type == Tok_Amp ) {
		if( expect(Tok_Amp, false, "MulOperator") ) addTerminal(st);
	} else
		invalid("MulOperator");
}

void Parser::literal(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_literal, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_number(la.d_type) ) {
		number(st);
	} else if( la.d_type == Tok_string ) {
		if( expect(Tok_string, false, "literal") ) addTerminal(st);
	} else if( la.d_type == Tok_hexstring ) {
		if( expect(Tok_hexstring, false, "literal") ) addTerminal(st);
	} else if( la.d_type == Tok_hexchar ) {
		if( expect(Tok_hexchar, false, "literal") ) addTerminal(st);
	} else if( la.d_type == Tok_NIL ) {
		if( expect(Tok_NIL, false, "literal") ) addTerminal(st);
	} else if( FIRST_set(la.d_type) ) {
		set(st);
	} else if( la.d_type == Tok_TRUE ) {
		if( expect(Tok_TRUE, false, "literal") ) addTerminal(st);
	} else if( la.d_type == Tok_FALSE ) {
		if( expect(Tok_FALSE, false, "literal") ) addTerminal(st);
	} else
		invalid("literal");
}

void Parser::factor(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_factor, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_literal(la.d_type) ) {
		literal(st);
	} else if( FIRST_variableOrFunctionCall(la.d_type) ) {
		variableOrFunctionCall(st);
	} else if( la.d_type == Tok_Lpar ) {
		if( expect(Tok_Lpar, false, "factor") ) addTerminal(st);
		expression(st);
		if( expect(Tok_Rpar, false, "factor") ) addTerminal(st);
	} else if( la.d_type == Tok_Tilde ) {
		if( expect(Tok_Tilde, false, "factor") ) addTerminal(st);
		factor(st);
	} else
		invalid("factor");
}

void Parser::variableOrFunctionCall(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_variableOrFunctionCall, la); st->d_children.append(tmp); st = tmp; }
	designator(st);
}

void Parser::set(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_set, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lbrace, false, "set") ) addTerminal(st);
	if( FIRST_element(la.d_type) ) {
		element(st);
		while( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "set") ) addTerminal(st);
			element(st);
		}
	}
	if( expect(Tok_Rbrace, false, "set") ) addTerminal(st);
}

void Parser::element(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_element, la); st->d_children.append(tmp); st = tmp; }
	expression(st);
	if( la.d_type == Tok_2Dot ) {
		if( expect(Tok_2Dot, false, "element") ) addTerminal(st);
		expression(st);
	}
}

void Parser::statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_statement, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_assignmentOrProcedureCall(la.d_type) ) {
		assignmentOrProcedureCall(st);
	} else if( FIRST_IfStatement(la.d_type) ) {
		IfStatement(st);
	} else if( FIRST_CaseStatement(la.d_type) ) {
		CaseStatement(st);
	} else if( FIRST_WithStatement(la.d_type) ) {
		WithStatement(st);
	} else if( FIRST_LoopStatement(la.d_type) ) {
		LoopStatement(st);
	} else if( FIRST_ExitStatement(la.d_type) ) {
		ExitStatement(st);
	} else if( FIRST_ReturnStatement(la.d_type) ) {
		ReturnStatement(st);
	} else if( FIRST_WhileStatement(la.d_type) ) {
		WhileStatement(st);
	} else if( FIRST_RepeatStatement(la.d_type) ) {
		RepeatStatement(st);
	} else if( FIRST_ForStatement(la.d_type) ) {
		ForStatement(st);
	} else
		invalid("statement");
}

void Parser::assignmentOrProcedureCall(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_assignmentOrProcedureCall, la); st->d_children.append(tmp); st = tmp; }
	designator(st);
	if( la.d_type == Tok_ColonEq ) {
		if( expect(Tok_ColonEq, false, "assignmentOrProcedureCall") ) addTerminal(st);
		expression(st);
	}
}

void Parser::StatementSequence(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_StatementSequence, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_statement(la.d_type) ) {
		statement(st);
	}
	while( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "StatementSequence") ) addTerminal(st);
		if( FIRST_statement(la.d_type) ) {
			statement(st);
		}
	}
}

void Parser::IfStatement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_IfStatement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_IF, false, "IfStatement") ) addTerminal(st);
	expression(st);
	if( expect(Tok_THEN, false, "IfStatement") ) addTerminal(st);
	StatementSequence(st);
	while( FIRST_ElsifStatement(la.d_type) ) {
		ElsifStatement(st);
	}
	if( FIRST_ElseStatement(la.d_type) ) {
		ElseStatement(st);
	}
	if( expect(Tok_END, false, "IfStatement") ) addTerminal(st);
}

void Parser::ElsifStatement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ElsifStatement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ELSIF, false, "ElsifStatement") ) addTerminal(st);
	expression(st);
	if( expect(Tok_THEN, false, "ElsifStatement") ) addTerminal(st);
	StatementSequence(st);
}

void Parser::ElseStatement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ElseStatement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ELSE, false, "ElseStatement") ) addTerminal(st);
	StatementSequence(st);
}

void Parser::CaseStatement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_CaseStatement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_CASE, false, "CaseStatement") ) addTerminal(st);
	expression(st);
	if( expect(Tok_OF, false, "CaseStatement") ) addTerminal(st);
	Case(st);
	while( la.d_type == Tok_Bar ) {
		if( expect(Tok_Bar, false, "CaseStatement") ) addTerminal(st);
		Case(st);
	}
	if( la.d_type == Tok_ELSE ) {
		if( expect(Tok_ELSE, false, "CaseStatement") ) addTerminal(st);
		StatementSequence(st);
	}
	if( expect(Tok_END, false, "CaseStatement") ) addTerminal(st);
}

void Parser::Case(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Case, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_CaseLabelList(la.d_type) ) {
		CaseLabelList(st);
		if( expect(Tok_Colon, false, "Case") ) addTerminal(st);
		StatementSequence(st);
	}
}

void Parser::CaseLabelList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_CaseLabelList, la); st->d_children.append(tmp); st = tmp; }
	LabelRange(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "CaseLabelList") ) addTerminal(st);
		LabelRange(st);
	}
}

void Parser::LabelRange(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_LabelRange, la); st->d_children.append(tmp); st = tmp; }
	label(st);
	if( la.d_type == Tok_2Dot ) {
		if( expect(Tok_2Dot, false, "LabelRange") ) addTerminal(st);
		label(st);
	}
}

void Parser::label(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_label, la); st->d_children.append(tmp); st = tmp; }
	ConstExpression(st);
}

void Parser::WhileStatement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_WhileStatement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_WHILE, false, "WhileStatement") ) addTerminal(st);
	expression(st);
	if( expect(Tok_DO, false, "WhileStatement") ) addTerminal(st);
	StatementSequence(st);
	while( FIRST_ElsifStatement2(la.d_type) ) {
		ElsifStatement2(st);
	}
	if( expect(Tok_END, false, "WhileStatement") ) addTerminal(st);
}

void Parser::ElsifStatement2(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ElsifStatement2, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ELSIF, false, "ElsifStatement2") ) addTerminal(st);
	expression(st);
	if( expect(Tok_DO, false, "ElsifStatement2") ) addTerminal(st);
	StatementSequence(st);
}

void Parser::RepeatStatement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_RepeatStatement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_REPEAT, false, "RepeatStatement") ) addTerminal(st);
	StatementSequence(st);
	if( expect(Tok_UNTIL, false, "RepeatStatement") ) addTerminal(st);
	expression(st);
}

void Parser::ForStatement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ForStatement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_FOR, false, "ForStatement") ) addTerminal(st);
	if( expect(Tok_ident, false, "ForStatement") ) addTerminal(st);
	if( expect(Tok_ColonEq, false, "ForStatement") ) addTerminal(st);
	expression(st);
	if( expect(Tok_TO, false, "ForStatement") ) addTerminal(st);
	expression(st);
	if( la.d_type == Tok_BY ) {
		if( expect(Tok_BY, false, "ForStatement") ) addTerminal(st);
		ConstExpression(st);
	}
	if( expect(Tok_DO, false, "ForStatement") ) addTerminal(st);
	StatementSequence(st);
	if( expect(Tok_END, false, "ForStatement") ) addTerminal(st);
}

void Parser::WithStatement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_WithStatement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_WITH, false, "WithStatement") ) addTerminal(st);
	if( la.d_type == Tok_Bar ) {
		if( expect(Tok_Bar, false, "WithStatement") ) addTerminal(st);
	}
	Guard(st);
	if( expect(Tok_DO, false, "WithStatement") ) addTerminal(st);
	StatementSequence(st);
	while( la.d_type == Tok_Bar ) {
		if( expect(Tok_Bar, false, "WithStatement") ) addTerminal(st);
		Guard(st);
		if( expect(Tok_DO, false, "WithStatement") ) addTerminal(st);
		StatementSequence(st);
	}
	if( la.d_type == Tok_ELSE ) {
		if( expect(Tok_ELSE, false, "WithStatement") ) addTerminal(st);
		StatementSequence(st);
	}
	if( expect(Tok_END, false, "WithStatement") ) addTerminal(st);
}

void Parser::Guard(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Guard, la); st->d_children.append(tmp); st = tmp; }
	qualident(st);
	if( expect(Tok_Colon, false, "Guard") ) addTerminal(st);
	qualident(st);
}

void Parser::LoopStatement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_LoopStatement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_LOOP, false, "LoopStatement") ) addTerminal(st);
	StatementSequence(st);
	if( expect(Tok_END, false, "LoopStatement") ) addTerminal(st);
}

void Parser::ExitStatement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ExitStatement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_EXIT, false, "ExitStatement") ) addTerminal(st);
}

void Parser::ProcedureDeclaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ProcedureDeclaration, la); st->d_children.append(tmp); st = tmp; }
	if( ( peek(1).d_type == Tok_PROCEDURE && ( peek(2).d_type == Tok_Hat || peek(2).d_type == Tok_Minus ) )  ) {
		if( expect(Tok_PROCEDURE, false, "ProcedureDeclaration") ) addTerminal(st);
		if( la.d_type == Tok_Hat ) {
			if( expect(Tok_Hat, false, "ProcedureDeclaration") ) addTerminal(st);
		} else if( la.d_type == Tok_Minus ) {
			if( expect(Tok_Minus, false, "ProcedureDeclaration") ) addTerminal(st);
		} else
			invalid("ProcedureDeclaration");
		if( FIRST_Receiver(la.d_type) ) {
			Receiver(st);
		}
		identdef(st);
		if( FIRST_FormalParameters(la.d_type) ) {
			FormalParameters(st);
		}
		if( FIRST_literal(la.d_type) ) {
			literal(st);
		}
	} else if( FIRST_ProcedureHeading(la.d_type) ) {
		ProcedureHeading(st);
		if( la.d_type == Tok_Semi ) {
			if( expect(Tok_Semi, false, "ProcedureDeclaration") ) addTerminal(st);
		}
		ProcedureBody(st);
		if( la.d_type == Tok_ident ) {
			if( expect(Tok_ident, false, "ProcedureDeclaration") ) addTerminal(st);
		}
	} else
		invalid("ProcedureDeclaration");
}

void Parser::ProcedureHeading(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ProcedureHeading, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_PROCEDURE ) {
		if( expect(Tok_PROCEDURE, false, "ProcedureHeading") ) addTerminal(st);
	} else if( la.d_type == Tok_PROC ) {
		if( expect(Tok_PROC, false, "ProcedureHeading") ) addTerminal(st);
	} else
		invalid("ProcedureHeading");
	if( la.d_type == Tok_Star || la.d_type == Tok_Plus ) {
		if( la.d_type == Tok_Star ) {
			if( expect(Tok_Star, false, "ProcedureHeading") ) addTerminal(st);
		} else if( la.d_type == Tok_Plus ) {
			if( expect(Tok_Plus, false, "ProcedureHeading") ) addTerminal(st);
		} else
			invalid("ProcedureHeading");
	}
	if( FIRST_Receiver(la.d_type) ) {
		Receiver(st);
	}
	identdef(st);
	if( FIRST_FormalParameters(la.d_type) ) {
		FormalParameters(st);
	}
}

void Parser::Receiver(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Receiver, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lpar, false, "Receiver") ) addTerminal(st);
	if( la.d_type == Tok_VAR ) {
		if( expect(Tok_VAR, false, "Receiver") ) addTerminal(st);
	}
	if( expect(Tok_ident, false, "Receiver") ) addTerminal(st);
	if( expect(Tok_Colon, false, "Receiver") ) addTerminal(st);
	if( expect(Tok_ident, false, "Receiver") ) addTerminal(st);
	if( expect(Tok_Rpar, false, "Receiver") ) addTerminal(st);
}

void Parser::ProcedureBody(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ProcedureBody, la); st->d_children.append(tmp); st = tmp; }
	DeclarationSequence(st);
	if( la.d_type == Tok_BEGIN || la.d_type == Tok_DO || FIRST_ReturnStatement(la.d_type) ) {
		if( la.d_type == Tok_BEGIN || la.d_type == Tok_DO ) {
			if( la.d_type == Tok_BEGIN ) {
				if( expect(Tok_BEGIN, false, "ProcedureBody") ) addTerminal(st);
			} else if( la.d_type == Tok_DO ) {
				if( expect(Tok_DO, false, "ProcedureBody") ) addTerminal(st);
			} else
				invalid("ProcedureBody");
			StatementSequence(st);
		} else if( FIRST_ReturnStatement(la.d_type) ) {
			ReturnStatement(st);
			if( la.d_type == Tok_Semi ) {
				if( expect(Tok_Semi, false, "ProcedureBody") ) addTerminal(st);
			}
		} else
			invalid("ProcedureBody");
	}
	if( expect(Tok_END, false, "ProcedureBody") ) addTerminal(st);
}

void Parser::DeclarationSequence(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_DeclarationSequence, la); st->d_children.append(tmp); st = tmp; }
	while( la.d_type == Tok_CONST || la.d_type == Tok_TYPE || la.d_type == Tok_VAR ) {
		if( la.d_type == Tok_CONST ) {
			if( expect(Tok_CONST, false, "DeclarationSequence") ) addTerminal(st);
			while( FIRST_ConstDeclaration(la.d_type) ) {
				ConstDeclaration(st);
				if( expect(Tok_Semi, false, "DeclarationSequence") ) addTerminal(st);
			}
		} else if( la.d_type == Tok_TYPE ) {
			if( expect(Tok_TYPE, false, "DeclarationSequence") ) addTerminal(st);
			while( FIRST_TypeDeclaration(la.d_type) ) {
				TypeDeclaration(st);
				if( expect(Tok_Semi, false, "DeclarationSequence") ) addTerminal(st);
			}
		} else if( la.d_type == Tok_VAR ) {
			if( expect(Tok_VAR, false, "DeclarationSequence") ) addTerminal(st);
			while( FIRST_VariableDeclaration(la.d_type) ) {
				VariableDeclaration(st);
				if( expect(Tok_Semi, false, "DeclarationSequence") ) addTerminal(st);
			}
		} else
			invalid("DeclarationSequence");
	}
	while( FIRST_ProcedureDeclaration(la.d_type) ) {
		ProcedureDeclaration(st);
		if( expect(Tok_Semi, false, "DeclarationSequence") ) addTerminal(st);
	}
}

void Parser::ReturnStatement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ReturnStatement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_RETURN, false, "ReturnStatement") ) addTerminal(st);
	if( FIRST_expression(la.d_type) ) {
		expression(st);
	}
}

void Parser::DeclarationSequence2(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_DeclarationSequence2, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_CONST ) {
		if( expect(Tok_CONST, false, "DeclarationSequence2") ) addTerminal(st);
		while( FIRST_ConstDeclaration(la.d_type) ) {
			ConstDeclaration(st);
			if( expect(Tok_Semi, false, "DeclarationSequence2") ) addTerminal(st);
		}
	}
	if( la.d_type == Tok_TYPE ) {
		if( expect(Tok_TYPE, false, "DeclarationSequence2") ) addTerminal(st);
		while( FIRST_TypeDeclaration(la.d_type) ) {
			TypeDeclaration(st);
			if( expect(Tok_Semi, false, "DeclarationSequence2") ) addTerminal(st);
		}
	}
	if( la.d_type == Tok_VAR ) {
		if( expect(Tok_VAR, false, "DeclarationSequence2") ) addTerminal(st);
		while( FIRST_VariableDeclaration(la.d_type) ) {
			VariableDeclaration(st);
			if( expect(Tok_Semi, false, "DeclarationSequence2") ) addTerminal(st);
		}
	}
	while( FIRST_ProcedureHeading(la.d_type) ) {
		ProcedureHeading(st);
		if( expect(Tok_Semi, false, "DeclarationSequence2") ) addTerminal(st);
	}
}

void Parser::FormalParameters(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FormalParameters, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lpar, false, "FormalParameters") ) addTerminal(st);
	if( FIRST_FPSection(la.d_type) ) {
		FPSection(st);
		while( la.d_type == Tok_Semi ) {
			if( expect(Tok_Semi, false, "FormalParameters") ) addTerminal(st);
			FPSection(st);
		}
	}
	if( expect(Tok_Rpar, false, "FormalParameters") ) addTerminal(st);
	if( la.d_type == Tok_Colon ) {
		if( expect(Tok_Colon, false, "FormalParameters") ) addTerminal(st);
		NamedType(st);
	}
}

void Parser::FPSection(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FPSection, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_VAR ) {
		if( expect(Tok_VAR, false, "FPSection") ) addTerminal(st);
	}
	if( expect(Tok_ident, false, "FPSection") ) addTerminal(st);
	while( la.d_type == Tok_Comma || la.d_type == Tok_ident ) {
		if( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "FPSection") ) addTerminal(st);
		}
		if( expect(Tok_ident, false, "FPSection") ) addTerminal(st);
	}
	if( expect(Tok_Colon, false, "FPSection") ) addTerminal(st);
	FormalType(st);
}

void Parser::FormalType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FormalType, la); st->d_children.append(tmp); st = tmp; }
	type(st);
}

void Parser::module(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_module, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_MODULE, false, "module") ) addTerminal(st);
	if( expect(Tok_ident, false, "module") ) addTerminal(st);
	if( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "module") ) addTerminal(st);
	}
	if( FIRST_ImportList(la.d_type) ) {
		ImportList(st);
	}
	DeclarationSequence(st);
	if( la.d_type == Tok_BEGIN ) {
		if( expect(Tok_BEGIN, false, "module") ) addTerminal(st);
		StatementSequence(st);
	}
	if( expect(Tok_END, false, "module") ) addTerminal(st);
	if( expect(Tok_ident, false, "module") ) addTerminal(st);
	if( la.d_type == Tok_Dot ) {
		if( expect(Tok_Dot, false, "module") ) addTerminal(st);
	}
}

void Parser::ImportList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ImportList, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_IMPORT, false, "ImportList") ) addTerminal(st);
	import(st);
	while( la.d_type == Tok_Comma || FIRST_import(la.d_type) ) {
		if( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "ImportList") ) addTerminal(st);
		}
		import(st);
	}
	if( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "ImportList") ) addTerminal(st);
	}
}

void Parser::import(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_import, la); st->d_children.append(tmp); st = tmp; }
	if( ( peek(1).d_type == Tok_ident && peek(2).d_type == Tok_ColonEq )  ) {
		if( expect(Tok_ident, false, "import") ) addTerminal(st);
		if( expect(Tok_ColonEq, false, "import") ) addTerminal(st);
	}
	if( expect(Tok_ident, false, "import") ) addTerminal(st);
}

void Parser::definition(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_definition, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_DEFINITION, false, "definition") ) addTerminal(st);
	if( expect(Tok_ident, false, "definition") ) addTerminal(st);
	if( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "definition") ) addTerminal(st);
	}
	if( FIRST_ImportList(la.d_type) ) {
		ImportList(st);
	}
	DeclarationSequence2(st);
	if( expect(Tok_END, false, "definition") ) addTerminal(st);
	if( expect(Tok_ident, false, "definition") ) addTerminal(st);
	if( la.d_type == Tok_Dot ) {
		if( expect(Tok_Dot, false, "definition") ) addTerminal(st);
	}
}

