/*
* Copyright 2019 Rochus Keller <mailto:me@rochus-keller.ch>
*
* This file is part of the Oberon parser/code model library.
*
* The following is the license that applies to this copy of the
* library. For a license to use the library under conditions
* other than those described here, please email to me@rochus-keller.ch.
*
* GNU General Public License Usage
* This file may be used under the terms of the GNU General Public
* License (GPL) versions 2.0 or 3.0 as published by the Free Software
* Foundation and appearing in the file LICENSE.GPL included in
* the packaging of this file. Please review the following information
* to ensure GNU General Public Licensing requirements will be met:
* http://www.fsf.org/licensing/licenses/info/GPLv2.html and
* http://www.gnu.org/copyleft/gpl.html.
*/

#include "ObCppGen.h"
#include <QDir>
#include <QtDebug>
#include <QCoreApplication>
#include <QDateTime>
#include <memory>
#include <typeinfo>
using namespace Ob;

bool isCppKeyword( const QByteArray& str ); // aus CppKeywordDetector.cpp

static inline const CodeModel::Type* derefed( const CodeModel::Type* t )
{
    return ( t != 0 ? t->deref() : 0 );
}

static QByteArray quali( const SynTree* st )
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_qualident );
    if( st->d_children.size() == 1 )
        return st->d_children.first()->d_tok.d_val;
    else
        return st->d_children.first()->d_tok.d_val + "::" + st->d_children.last()->d_tok.d_val;
}

CppGen::CppGen(CodeModel* mdl):d_mdl(mdl),d_errs(0),d_genStubs(true)
{
    Q_ASSERT( mdl != 0 );
    d_errs = mdl->getErrs();
}

bool CppGen::error(Errors::Source s, const SynTree* st, const QString& msg)
{
    d_errs->error( s, st->d_tok.toLoc(), msg );
    return false;
}

bool CppGen::warning(Errors::Source s, const SynTree* st, const QString& msg)
{
    d_errs->warning( s, st->d_tok.toLoc(), msg );
    return false;
}

bool CppGen::emitModules(const QString& outdir, const QString& ns, const QString& mod)
{
    d_ns = ns;
    d_outdir = outdir;
    d_mod = mod;
    d_nameNr = 1;
#if defined(OB_BBOX) || defined(OB_OBN2) || defined(OB_OBNX)
    qWarning() << "CppGen does not support Oberon-2, Oberon 90, Oberon+ or Blackbox; crashes are likely";
#endif
    const int precount = d_errs->getErrCount();
    foreach( CodeModel::Module* m, d_mdl->getGlobalScope().d_mods )
    {
        qDebug() << "translating module" << m->d_name;
        emitModule(m);
    }
    return precount == int(d_errs->getErrCount());
}

void CppGen::emitModule(const CodeModel::Module* m)
{
    QDir dir(d_outdir);
    if( !d_mod.isEmpty() )
    {
        dir.mkpath( d_mod );
        dir.cd( d_mod );
    }
    QFile hfile( dir.absoluteFilePath( d_ns + m->d_name + ".h" ));
    if( !hfile.open(QIODevice::WriteOnly ) )
    {
        d_errs->error(Errors::Generator,m->d_name, 0,0,QString("cannot open file '%1' for writing").arg(hfile.fileName()) );
        return;
    }

    QTextStream hout(&hfile);

    const QString guard = QString("__%1%2_H__").arg(d_ns).arg(m->d_name.data());
    hout << "#ifndef " << guard << endl;
    hout << "#define " << guard << endl << endl;

    hout << "// Generated by " << qApp->applicationName() << " " << qApp->applicationVersion() <<
            " on " << QDateTime::currentDateTime().toString(Qt::ISODate) << endl << endl;

    hout << "#include <" << includeFileName( "_Global" ) << ".h>" << endl;
    foreach( CodeModel::Module* dep, m->d_using )
        hout << "#include <" << includeFileName( dep->d_name ) << ".h>" << endl;
    hout << endl;

    int lh = 0;
    if( !d_ns.isEmpty() )
    {
        hout << "namespace " << d_ns << endl << "{" << endl;
        lh++;
    }

    d_cmts.clear();
    if( m->d_def )
        d_cmts = d_mdl->getComments(m->d_def->d_tok.d_sourcePath);
    d_nextCmt = 0;

    emitHeader(m,hout,lh);

    if( !d_ns.isEmpty() )
        hout << "}" << endl << endl;

    hout << "#endif // " << guard;


    if( m->d_def != 0 )
    {
        QFile bfile( dir.absoluteFilePath( d_ns + m->d_name + ".cpp" ));
        if( !bfile.open(QIODevice::WriteOnly ) )
        {
            d_errs->error(Errors::Generator,m->d_name, 0,0,QString("cannot open file '%1' for writing").arg(bfile.fileName()) );
            return;
        }

        QTextStream bout(&bfile);

        bout << "// Generated by " << qApp->applicationName() << " " << qApp->applicationVersion() <<
                " on " << QDateTime::currentDateTime().toString(Qt::ISODate) << endl;
        bout << "#include \"" << d_ns << m->d_name << ".h\"" << endl;
        bout << "#include <memory>" << endl;
        if( !d_ns.isEmpty() )
            bout << "using namespace " << d_ns << ";" << endl << endl;

        emitBody(m,bout);
    }
}

void CppGen::emitHeader(const CodeModel::Module* m, QTextStream& out, int l)
{
    out << ws(l) << "class " << escape(m->d_name) << " : public _Root" << endl <<
            ws(l) << "{" << endl <<
            ws(l) << "public:" << endl;
    l++;
    emitComment(m->d_def,out,l);
    out << ws(l) << "static " << escape(m->d_name) << "* _inst();" << endl;
    out << ws(l) << escape(m->d_name) << "();" << endl;
    out << ws(l) << "~" << escape(m->d_name) << "();" << endl << endl;

    emitDecls(m,out,l);

    if( !m->d_procs.isEmpty() )
        out << ws(l) << "// PROC" << endl;
    foreach( const CodeModel::Procedure* v, m->d_procs )
    {
        emitProcDecl(v,out,l);
    }
    if( !m->d_procs.isEmpty() )
        out << endl;


    l--;
    out << ws(l) << "};" << endl;
}

void CppGen::emitBody(const CodeModel::Module* m, QTextStream& out )
{
    out << "static std::auto_ptr<" << escape(m->d_name) << "> s_inst;" << endl << endl;

    foreach( const CodeModel::Element* c, m->getConsts() )
    {
        out << "const ";
        const CodeModel::Type* type = d_mdl->typeOfExpression(m,c->d_st);
        emitType( m, type, out, 0 );
        out << " " << escape(m->d_name) << "::" << escape(c->d_name) << ";" << endl;
    }
    out << endl;

    out << escape(m->d_name) << "* " << escape(m->d_name) << "::_inst()" << endl << "{" << endl;
    out << ws(1) << "if( s_inst.get() == 0 )" << endl;
    out << ws(2) <<    "s_inst.reset( new " << escape(m->d_name) << "() );" << endl;
    out << ws(1) << "return s_inst.get();" << endl;
    out << "}" << endl << endl;

    foreach( const CodeModel::Procedure* v, m->d_procs )
    {
        emitProcBody(v,out);
    }

    // Constructor
    out << escape(m->d_name) << "::" << escape(m->d_name) << "()" << endl << "{" << endl;
    if( !m->d_body.isEmpty() )
        out << ws(1) << "// BEGIN" << endl;
    emitStatementSeq(m, m->d_body, out,1);
    if( !m->d_body.isEmpty() )
        out << ws(1) << "// END" << endl;
    out << "}" << endl << endl;

    // Destructor
    out << escape(m->d_name) << "::~" << escape(m->d_name) << "()" << endl << "{" << endl;
    out << ws(1) << "s_inst.release();" << endl;
    out << "}" << endl << endl;

}

QString CppGen::includeFileName(const QString& modName)
{
    QString path;
    if( !d_mod.isEmpty() )
        path = d_mod + "/";
    if( !d_ns.isEmpty() )
        path += d_ns;
    path += modName;
    return path;
}

QString CppGen::ws(int level)
{
    return QString(level,QChar('\t'));
}

QString CppGen::basicType(const CodeModel::Type* t)
{
    if( t == 0 )
        return "int /* unknown type */";
    switch( t->d_kind )
    {
    case CodeModel::Type::BOOLEAN:
        return "bool";
    case CodeModel::Type::CHAR:
        return "char";
    case CodeModel::Type::INTEGER:
        return "int";
    case CodeModel::Type::REAL:
        return "float";
    case CodeModel::Type::BYTE:
        return "uint8_t";
    case CodeModel::Type::SET:
        return "_Set";
    case CodeModel::Type::STRING:
        return "_ValArray<char>";
    case CodeModel::Type::NIL:
        return "void*";
    default:
        break;
    }
    Q_ASSERT( false );
    return QString();
}

void CppGen::emitType(const CodeModel::Unit* ds,const CodeModel::Type* t, QTextStream& out, int level )
{
    if( t != 0 )
    {
        if( t->isBasicType() )
            out << basicType(t);
        else if( t->d_kind == CodeModel::Type::TypeRef )
        {
            const CodeModel::Type* b = t->d_type;
            if( b && b->isBasicType() )
                out << basicType(b);
            else
            {
                CodeModel::Quali q = d_mdl->derefQualident( ds, t->d_st );
                if( q.second.first )
                {
                    if( q.first.first )
                        out << escape(q.first.first->d_name) << "::";
                    if( q.second.first )
                        out << escape(q.second.first->d_name);
                }else
                    out << "Unknown";
            }
        }else if( t->d_kind == CodeModel::Type::Array )
        {
            if( t->d_type != 0 )
            {
                Q_ASSERT( t->d_type->d_name.isEmpty() );
                if( t && ( t->d_type->d_kind == CodeModel::Type::TypeRef || t->d_type->d_kind == CodeModel::Type::Array ) )
                {
                    out << "_FxArray<";
                    emitType(ds, t->d_type, out, level );
                }else
                {
                    // qDebug() << "Array Type" << SynTree::rToStr(t->d_type->d_def->d_tok.d_type);
                    // Erzeuge Namen und f√ºge Type Decl ein
                    const QByteArray name = "_Type" + QByteArray::number(d_nameNr++);
                    out << "_FxArray<";
                    out << name;

                }
            }else
                out << "_FxArray<Unknown";

            if( t->d_st )
            {
                out << ",";
                emitExpression(ds,t->d_st,out,level);
            }else
                out << ",0";
//            if( t->d_type && t->d_type->d_kind == CodeModel::Type::Array )
//                out << " ";
            out << ">";
        }else if( t->d_kind == CodeModel::Type::Record )
            emitRecDecl(ds,t,QByteArray(),out,level);
        else if( t->d_kind == CodeModel::Type::Pointer )
        {
            emitType(ds,t->d_type,out,level);
            out << "*";
        }
        else if( t->d_kind == CodeModel::Type::ProcRef )
            out << "/* ProcType not supported here */";
        else
            out << "int /* unknown type */";
    }else
        out << "int /* unknown type */";
}

void CppGen::emitProcType(const CodeModel::Unit* ds, const CodeModel::Type* p, const QByteArray& name, QTextStream& out, int level)
{
    Q_ASSERT( p->d_kind == CodeModel::Type::ProcRef );
    if( p->d_type == 0 )
        out << "void ";
    else
    {
        emitType(ds,p->d_type,out,level);
        out << " ";
    }
    out << "(*" << name << ")(";
    CodeModel::Type::Vals::const_iterator i;
    for( i = p->d_vals.begin(); i != p->d_vals.end(); ++i )
    {
        if( i != p->d_vals.begin() )
            out << ",";
        const CodeModel::Element* par = i.value();
        emitType(ds,par->d_type,out,level);
        if( par->d_var )
            out << "&";
    }
    out << ")";
}

void CppGen::emitFactor(const CodeModel::Unit* ds,const SynTree* st, QTextStream& out, int level )
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_factor && !st->d_children.isEmpty() );
    const SynTree* first = st->d_children.first();
    switch( first->d_tok.d_type )
    {
    case SynTree::R_literal:
        emitLiteral(ds,first,out, level);
        break;
    case Tok_Lpar:
        out << "(";
        Q_ASSERT(st->d_children.size() == 3);
        emitExpression(ds,st->d_children[1],out,level);
        out << ")";
        break;
    case Tok_Tilde:
        out << "!";
        Q_ASSERT(st->d_children.size() == 2 );
        emitFactor(ds,st->d_children[1], out, level );
        break;
    case SynTree::R_variableOrFunctionCall:
        emitDesig(ds,first->d_children.first(), false, out,level);
        break;
    default:
        Q_ASSERT( false );
        break;
    }
}

void CppGen::emitLiteral(const CodeModel::Unit* ds,const SynTree* st, QTextStream& out, int level )
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_literal && !st->d_children.isEmpty() );
    const SynTree* first = st->d_children.first();
    switch( first->d_tok.d_type )
    {
    case SynTree::R_set:
        emitSet(ds,first,out, level);
        break;
    case SynTree::R_number:
        Q_ASSERT( !st->d_children.first()->d_children.isEmpty() );
        if( st->d_children.first()->d_children.first()->d_tok.d_val.endsWith('H') )
            out << "0x" << st->d_children.first()->d_children.first()->d_tok.d_val.left(
                       st->d_children.first()->d_children.first()->d_tok.d_val.size() - 1 );
        else
            out << st->d_children.first()->d_children.first()->d_tok.d_val;
        break;
#ifndef OB_BBOX
    case Tok_TRUE:
        out << "true";
        break;
    case Tok_FALSE:
        out << "false";
        break;
#endif
    case Tok_NIL:
        out << "0";
        break;
    case Tok_string:
        if( first->d_tok.d_val.size() == 3 )
            out << "'" << ( first->d_tok.d_val[1] == '\'' ? "\\" : "" ) << first->d_tok.d_val[1] << "'"; // CHAR
        else
            out << first->d_tok.d_val;
        break;
    case Tok_hexchar:
        out << "0x" << first->d_tok.d_val.left(first->d_tok.d_val.size() - 1 );
        break;
    case Tok_hexstring:
        out << "\"" << first->d_tok.d_val << "\"";
        break;
    default:
        Q_ASSERT( false );
        break;
    }
}

bool CppGen::emitDesig(const CodeModel::Unit* ds, const SynTree* st, bool procCall, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_designator );
    CodeModel::DesigOpList dopl = d_mdl->derefDesignator(ds,st);

    bool printedSomething = false;
    bool lastIsPointer = false;
    for( int i = 0; i < dopl.size(); i++ )
    {
        switch( dopl[i].d_op )
        {
        case CodeModel::IdentOp:
            if( dopl[i].d_sym == 0 )
                out << "/* ERROR: emitDesig: ident with no symbol: " << dopl[i].d_arg->d_tok.d_val << " */";
            if( i == 0 && dynamic_cast<const CodeModel::Module*>(dopl[i].d_sym) )
            {
                out << escape(dopl[i].d_sym->d_name) + "::_inst()";
                lastIsPointer = true;
                printedSomething = true;
            }else
            {
                const CodeModel::Element* e = dynamic_cast<const CodeModel::Element*>( dopl[i].d_sym );
                if( e && e->isPredefProc() )
                {
                    if( emitPredefProc( ds, dopl, out, level ) )
                        return true;
                    else
                        out << escape(e->d_name);
                }else
                {
                    if( i != 0 )
                    {
                        if( lastIsPointer )
                            out << "->";
                        else
                            out << ".";
                        lastIsPointer = false;
                    }

                    if( i == 0 && dynamic_cast<const CodeModel::Module*>(ds) == 0  // wir sind also nicht im Constructor
                         && dopl[i].d_sym &&
                         dynamic_cast<const CodeModel::Module*>(dopl[i].d_sym->d_scope) != 0 // es ist also eine Modulvariable
                                          )
                        out << "_this->";
                    if( dopl[i].d_sym )
                        out << escape(dopl[i].d_sym->d_name);
                    else
                        out << "???";
                    if( e && e->d_kind == CodeModel::Element::Variable )
                    {
                        const CodeModel::Type* t = derefed(e->d_type);
                        lastIsPointer = ( t != 0 && t->d_kind == CodeModel::Type::Pointer );
                    }
                }
            }
            break;
        case CodeModel::PointerOp:
            lastIsPointer = true;
            break;
        case CodeModel::TypeOp:
            {
                if( lastIsPointer )
                    out << "->";
                else
                    out << ".";
                out << "_to<" << quali(dopl[i].d_arg) << ">()";
                lastIsPointer = false;
                const CodeModel::Type* t = derefed(dynamic_cast<const CodeModel::Type*>(dopl[i].d_sym));
                if( t && t->d_kind == CodeModel::Type::Pointer )
                    lastIsPointer = true;
            }
            break;
        case CodeModel::ProcedureOp:
            out << "(";
            if( dopl[i].d_arg )
            {
                Q_ASSERT( dopl[i].d_arg->d_tok.d_type == SynTree::R_ExpList );
                for( int j = 0; j < dopl[i].d_arg->d_children.size(); j++ )
                {
                    if( j != 0 )
                        out << ", ";
                    emitExpression(ds, dopl[i].d_arg->d_children[j], out, 0 );
                }
            }
            out << ")";
            break;
        case CodeModel::ArrayOp:
            Q_ASSERT( dopl[i].d_arg->d_tok.d_type == SynTree::R_ExpList );
            for( int j = 0; j < dopl[i].d_arg->d_children.size(); j++ )
            {
                out << "[";
                emitExpression(ds, dopl[i].d_arg->d_children[j], out, 0 );
                out << "]"; // TODO: check for pointers?
            }
            break;
        default:
            break;
        }
    }
    if( procCall && !dopl.isEmpty() && dopl.last().d_op != CodeModel::ProcedureOp )
    {
        bool isCallWithoutParams = false;
        if( const CodeModel::Element* e = dynamic_cast<const CodeModel::Element*>(dopl.last().d_sym) )
        {
            isCallWithoutParams = ( e->d_kind == CodeModel::Element::StubProc ) ||
                    ( e->d_type && e->d_type->d_kind == CodeModel::Type::ProcRef );
        }else if( const CodeModel::Procedure* p = dynamic_cast<const CodeModel::Procedure*>(dopl.last().d_sym) )
            isCallWithoutParams = true;
        else if( const CodeModel::Type* t = dynamic_cast<const CodeModel::Type*>(dopl.last().d_sym) )
            isCallWithoutParams = t->d_kind == CodeModel::Type::ProcRef;
        if( isCallWithoutParams )
            out << "()";
    }

    return printedSomething;
}

void CppGen::emitTypeDecl(const CodeModel::Unit* ds, const CodeModel::Type* t, QTextStream& out, int level)
{
    Q_ASSERT( !t->d_name.isEmpty() );
    out << ws(level);
    if( t->d_kind == CodeModel::Type::Record )
    {
        emitRecDecl(ds,t,escape(t->d_name),out,level);
        out << ";" << endl;
    }else
    {
        out << "typedef ";
        emitType( ds, t, out, level );
        out << " " << escape(t->d_name) << ";" << endl;
    }
}

void CppGen::emitVarDecl(const CodeModel::Unit* ds, const CodeModel::Element* v, QTextStream& out, int level)
{
    // auch Unknowns kommen hier an Q_ASSERT( v->d_kind == CodeModel::Element::Variable );
    out << ws(level);
    if( v->d_type && v->d_type->d_kind == CodeModel::Type::ProcRef )
    {
        emitProcType(ds,v->d_type,escape(v->d_name),out,level);
        out << ";" << endl;
    }else
    {
        emitType( ds, v->d_type, out, level );
        out << " " << escape(v->d_name) << ";" << endl;
    }
}

void CppGen::emitStubProcDecl(const CodeModel::Unit* ds, const CodeModel::Element* v, QTextStream& out, int level)
{
    Q_ASSERT( v->d_kind == CodeModel::Element::StubProc );

    out << ws(level);

    if( v->d_type == 0 )
        out << "static void ";
    else
    {
        emitType(ds,v->d_type,out,level);
        out << " ";
    }
    out << escape(v->d_name);
    emitProcParams( ds, v->d_vals, out );
    out << ";" << endl;
}

void CppGen::emitRecDecl(const CodeModel::Unit* ds, const CodeModel::Type* r, const QByteArray& name,
                             QTextStream& out, int level)
{
    Q_ASSERT( r->d_kind == CodeModel::Type::Record );
    out << "struct " << name << ( name.isEmpty() ? "" : " " );
    out << ": public ";
    if( r->d_type )
        emitType(ds,r->d_type,out,level);
    else
        out << "_Root";

    out << " ";

    out << "{" << endl;
    foreach( const CodeModel::Element* v, r->d_vals )
    {
        emitVarDecl(ds,v,out,level+1);
    }
    out << ws(level) << "}";
}

void CppGen::emitProcDecl(const CodeModel::Procedure* p, QTextStream& out, int level)
{
    out << ws(level);
    if( p->d_type == 0 )
        out << "static void ";
    else
    {
        emitType(p,p->d_type,out,level);
        out << " ";
    }
    out << escape(p->d_name);
    emitProcParams(p, p->d_vals, out );
    out << ";" << endl;
}

void CppGen::emitProcParams( const CodeModel::Unit* ds, const QList<CodeModel::Element*>& params, QTextStream& out)
{
    out << "(";
    for( int i = 0; i < params.size(); i++ )
    {
        if( i != 0 )
            out << ", ";
        const CodeModel::Element* par = params[i];
        const CodeModel::Type* t = derefed(par->d_type);
        if( t && t->d_kind == CodeModel::Type::Array )
        {
            if( par->d_var )
                out << "_VarArray<";
            else
                out << "_ValArray<";
            emitType(ds, t->d_type, out, 0 );
            out << ">";
        }else
        {
            const bool isSimple = isSimpleType( par->d_type );
            if( !par->d_var && !isSimple )
                out << "const ";
            emitType(ds,par->d_type,out,0);
            if( par->d_var || !isSimple )
                out << "&";
        }
        out << " " << escape(par->d_name);
    }
    out << ")";
}

void CppGen::emitProcBody(const CodeModel::Procedure* p, QTextStream& out)
{
    const CodeModel::Module* m = p->getModule();
    Q_ASSERT( m != 0 );

    emitComment(p->d_def,out,0);

    if( p->d_type == 0 )
        out << "void ";
    else
    {
        // Return kann nur ein Qualident sein
        Q_ASSERT( p->d_type->d_kind == CodeModel::Type::TypeRef && p->d_type->d_st != 0 );
        // Hier einfach den Modulnamen vorstellen, falls d_type nicht bereits ein zweiteiliger Qualident ist
        const CodeModel::Type* der = p->d_type->deref();
        if( p->d_type->d_st->d_children.size() == 1 && der && !der->isBasicType() )
            out << escape(p->d_scope->d_name) << "::";
        emitType(p,p->d_type,out,0);
        out << " ";
    }
    out << escape(m->d_name) << "::" << escape(p->d_name);
    emitProcParams(p, p->d_vals, out );
    out << endl << "{" << endl;
    emitDecls(p,out,1);

    if( !p->d_body.isEmpty() )
    {
        out << ws(1) << "// BEGIN" << endl;
        out << ws(1) << escape(m->d_name) << "* _this = _inst();" << endl;
    }
    emitStatementSeq(p,p->d_body,out,1);
    if( !p->d_body.isEmpty() )
        out << ws(1) << "// END" << endl;

    out << "}" << endl << endl;
}

void CppGen::emitDecls(const CodeModel::Unit* ds, QTextStream& out, int l)
{
    QList<CodeModel::Element*> consts = ds->getConsts();
    if( !consts.isEmpty() )
        out << ws(l) << "// CONST" << endl;
    foreach( const CodeModel::Element* c, consts )
    {
        emitComment( c->d_def, out,l );
        out << ws(l) << "static const ";
        const CodeModel::Type* type = d_mdl->typeOfExpression(ds,c->d_st);
        if( type == 0 )
            type = d_mdl->typeOfExpression(ds,c->d_st);
        emitType( ds, type, out, l );
        out << " " << escape(c->d_name) << " = ";
        emitExpression( ds, c->d_st, out, l );
        out << ";" << endl;
    }
    if( !consts.isEmpty() )
        out << endl;

    QList<CodeModel::Type*> namedTypes = ds->getNamedTypes();
    if( !namedTypes.isEmpty() )
        out << ws(l) << "// TYPE" << endl;
    bool hasForwards = false;
    foreach( const CodeModel::Type* t, namedTypes )
    {
        // forward declarations because of typedef pointer to record
        if( t->d_kind == CodeModel::Type::Record )
        {
            out << ws(l) << "struct " << escape(t->d_name) << ";" << endl;
            hasForwards = true;
        }
    }
    if( hasForwards )
        out << endl;

    foreach( const CodeModel::Type* t, namedTypes )
    {
        emitComment( t->d_def, out,l );
        emitTypeDecl(ds,t,out,l);
    }
    if( !namedTypes.isEmpty() )
        out << endl;

    QList<CodeModel::Element*> vars = ds->getVars();
    if( !vars.isEmpty() )
        out << ws(l) << "// VAR" << endl;
    foreach( const CodeModel::Element* v, vars )
    {
        emitComment( v->d_def, out,l );
        emitVarDecl(ds,v,out,l);
    }
    QList<CodeModel::Element*> uknw = ds->getUnknowns();
    foreach( const CodeModel::Element* v, uknw )
    {
        emitVarDecl(ds,v,out,l);
    }
    if( !vars.isEmpty() )
        out << endl;

    foreach( const CodeModel::Element* v, ds->getStubProcs() )
    {
        emitStubProcDecl(ds,v,out,l);
    }
}

void CppGen::emitStatementSeq(const CodeModel::Unit* ds, const QList<SynTree*>& seq, QTextStream& out, int level)
{
    int count = 0;
    foreach( const SynTree* s, seq )
    {
        if( s->d_tok.d_type == SynTree::R_statement )
        {
            Q_ASSERT( s->d_children.size() <= 1 );
            if( s->d_children.isEmpty() )
                continue;
            else
                s = s->d_children.first();
        }
        emitComment(s,out,level);
        count++;
        switch( s->d_tok.d_type )
        {
        case SynTree::R_assignmentOrProcedureCall:
            Q_ASSERT( false ); // wurde bereits vorher korrigiert
            break;
        case SynTree::R_assignment_:
            out << ws(level);
            emitDesig(ds, s->d_children.first(), false, out, level);
            out << " = ";
            emitExpression(ds,s->d_children.last(), out, level );
            out << ";" << endl;
            break;
        case SynTree::R_ProcedureCall_:
            out << ws(level);
            emitDesig(ds, s->d_children.first(), true, out, level);
            out << ";" << endl;
            break;
        case SynTree::R_IfStatement:
            emitIfStatement(ds, s, out, level );
            break;
        case SynTree::R_CaseStatement:
            emitCaseStatement(ds,s,out,level);
            break;
        case SynTree::R_WhileStatement:
            emitWhileStatement(ds,s,out,level);
            break;
        case SynTree::R_RepeatStatement:
            emitRepeatStatement(ds,s,out,level);
            break;
        case SynTree::R_ForStatement:
            emitForStatement(ds,s,out,level);
            break;
        case SynTree::R_ReturnStatement:
            out << ws(level) << "return ";
            if( s->d_children.size() == 2 && s->d_children.last()->d_tok.d_type == SynTree::R_expression )
                emitExpression(ds, s->d_children.last(), out, level );
            else
                out << "/* ERROR: invalid return expression */";
            out << ";" << endl;
            break;
        default:
            out << ws(level) << "; // unknown statement " << SynTree::rToStr(s->d_tok.d_type) << endl;
            warning( Errors::Generator, s,
                                       tr("'%1' not yet supported").arg(SynTree::rToStr(s->d_tok.d_type)) );
            break;
        }
    }
    if( count == 0 )
    {
        out << ws(level) << "; // empty statement" << endl;
    }
}

bool CppGen::emitPredefProc(const CodeModel::Unit* ds, const CodeModel::DesigOpList& dopl, QTextStream& out, int level)
{
    Q_ASSERT( !dopl.isEmpty() );
    const CodeModel::Element* pp = dopl.first().d_sym->to<CodeModel::Element>();
    Q_ASSERT( pp != 0 && pp->isPredefProc() );
    if( dopl.size() != 2 || dopl.last().d_op != CodeModel::ProcedureOp )
    {
        return error( Errors::Semantics, dopl.first().d_arg, tr("invalid call of built-in procedure '%1'").
                       arg(dopl.first().d_sym->d_name.data()) );
    }
    Q_ASSERT( dopl.last().d_arg->d_tok.d_type == SynTree::R_ExpList );
    QList<SynTree*> args = dopl.last().d_arg->d_children;

    switch( pp->d_kind )
    {
    case CodeModel::Element::NEW:
        {
            const SynTree* desig = ( args.isEmpty() ? 0 : CodeModel::flatten(args.first(), SynTree::R_designator ) );
            if( args.size() != 1 || desig == 0 )
            {
                return error( Errors::Semantics, dopl.last().d_arg, tr("invalid arguments of 'NEW()'") );
            }
            CodeModel::DesigOpList arg = d_mdl->derefDesignator( ds, desig );
            const CodeModel::Element* id = 0;
            const CodeModel::Type* ptr = 0;
            const CodeModel::Type* rec = 0;
            if( arg.isEmpty() || arg.last().d_op != CodeModel::IdentOp ||
                    ( id = arg.last().d_sym->to<CodeModel::Element>() ) == 0 ||
                    ( ptr = derefed( id->d_type ) ) == 0 || ptr->d_kind != CodeModel::Type::Pointer ||
                    ( rec = derefed( ptr->d_type ) ) == 0 || rec->d_kind != CodeModel::Type::Record )
            {
                error( Errors::Semantics, dopl.last().d_arg, tr("'NEW()' expects a POINTER to RECORD") );
                return false;
            }
            emitDesig(ds, desig, false, out, level );
            out << " = new ";
            emitScopedName( ds, rec, out );
            out << "()";
//            if( rec->d_scope != ds )
//                out << escape(rec->d_scope->d_name) << "::";
//            out << escape(rec->d_name) << "()";
            return true;
        }
        break;
    case CodeModel::Element::INC:
        if( args.size() == 1 )
        {
            emitExpression( ds, args.first(), out , level );
            out << "++";
            return true;
        }else if( args.size() == 2 )
        {
            emitExpression( ds, args.first(), out , level );
            out << " += ";
            emitExpression( ds, args.last(), out , level );
            return true;
        }
        error( Errors::Semantics, pp->d_def, tr("'INC()' with invalid arguments") );
        break;
    case CodeModel::Element::DEC:
        if( args.size() == 1 )
        {
            emitExpression( ds, args.first(), out , level );
            out << "--";
            return true;
        }else if( args.size() == 2 )
        {
            emitExpression( ds, args.first(), out , level );
            out << " -= ";
            emitExpression( ds, args.last(), out , level );
            return true;
        }
        error( Errors::Semantics, dopl.last().d_arg, tr("'DEC()' with invalid arguments") );
        break;
    case CodeModel::Element::ORD:
        if( args.size() == 1 )
        {
            const CodeModel::Type* t = d_mdl->typeOfExpression(ds, args.first() );
            if( t == d_mdl->getGlobalScope().d_setType )
            {
                out << "( ";
                emitExpression(ds, args.first(), out, level );
                out << " ).to_ulong()";
                return true;
            }else
            {
                out << "int( ";
                emitExpression(ds, args.first(), out, level );
                out << " )";
                return true;
            }
        }
        error( Errors::Semantics, dopl.last().d_arg, tr("'ORD()' with invalid arguments") );
        break;
    case CodeModel::Element::CHR:
        if( args.size() == 1 )
        {
            out << "char( ";
            emitExpression(ds, args.first(), out, level );
            out << " )";
            return true;
        }
        error( Errors::Semantics, dopl.last().d_arg, tr("'CHR()' with invalid arguments") );
        break;
    case CodeModel::Element::ODD:
        if( args.size() == 1 )
        {
            emitExpression(ds, args.first(), out, level );
            out << " % 2 == 1";
            return true;
        }
        error( Errors::Semantics, dopl.last().d_arg, tr("'ODD()' with invalid arguments") );
        break;
    default:
        warning( Errors::Generator, dopl.last().d_arg,
                                   tr("built-in '%1()' not yet supported").arg(pp->d_name.data()) );
        break;
    }
    return false;
}

static inline bool ifNeedsBlock( SynTree* stats )
{
    Q_ASSERT( stats->d_tok.d_type == SynTree::R_StatementSequence );
    if( stats->d_children.isEmpty() )
        return false;
    SynTree* stat = stats->d_children.first();
    Q_ASSERT( stat->d_tok.d_type == SynTree::R_statement );
    if( stat->d_children.isEmpty() )
        return false;
    const int t = stat->d_children.first()->d_tok.d_type;
    if( t == SynTree::R_IfStatement || t == SynTree::R_CaseStatement )
        return true;
    else
        return stats->d_children.size() > 1;
}

void CppGen::emitIfStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_IfStatement && st->d_children.size() >= 4 &&
            st->d_children[1]->d_tok.d_type == SynTree::R_expression &&
              st->d_children[3]->d_tok.d_type == SynTree::R_StatementSequence );

    out << ws(level) << "if( ";
    emitExpression(ds,st->d_children[1],out,level);
    out << " )" << endl;
    SynTree* stats = st->d_children[3];
    bool block = ifNeedsBlock(stats);
    if( block )
        out << ws(level) << "{" << endl;
    emitStatementSeq(ds, stats->d_children, out, level + 1);
    out << ws(level);
    if( block )
        out << "}";
    for( int i = 4; i < st->d_children.size(); i++ )
    {
        if( st->d_children[i]->d_tok.d_type == SynTree::R_ElsifStatement )
        {
            SynTree* elif = st->d_children[i];
            Q_ASSERT( elif->d_children.size() == 4 && elif->d_children[1]->d_tok.d_type == SynTree::R_expression &&
                      elif->d_children[3]->d_tok.d_type == SynTree::R_StatementSequence );
            out << "else if( ";
            emitExpression(ds,elif->d_children[1],out,level);
            out << " )" << endl;
            SynTree* stats = elif->d_children[3];
            block = ifNeedsBlock(stats);
            if( block )
                out << ws(level) << "{" << endl;
            emitStatementSeq(ds, stats->d_children, out, level + 1);
            out << ws(level);
            if( block )
                out << "}";
        }else if( st->d_children[i]->d_tok.d_type == SynTree::R_ElseStatement )
        {
            SynTree* els = st->d_children[i];
            Q_ASSERT( els->d_children.size() == 2 && els->d_children[1]->d_tok.d_type == SynTree::R_StatementSequence );
            out << "else" << endl;
            SynTree* stats = els->d_children[1];
            block = ifNeedsBlock(stats);
            if( block )
                out << ws(level) << "{" << endl;
            emitStatementSeq(ds, stats->d_children, out, level + 1);
            if( block )
                out << ws(level) << "}";
        }
    }
    out << endl;
}

void CppGen::emitWhileStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_WhileStatement && st->d_children.size() >= 4 &&
            st->d_children[1]->d_tok.d_type == SynTree::R_expression &&
              st->d_children[3]->d_tok.d_type == SynTree::R_StatementSequence );

    out << ws(level) << "while( ";
    emitExpression(ds,st->d_children[1],out,level);
    out << " )" << endl;
    SynTree* stats = st->d_children[3];
    if( stats->d_children.size() > 1 )
        out << ws(level) << "{" << endl;
    emitStatementSeq(ds, stats->d_children, out, level + 1);
    out << ws(level);
    if( stats->d_children.size() > 1 )
        out << "}";
    out << endl;
    if( CodeModel::findFirstChild( st, SynTree::R_ElsifStatement ) != 0 )
        warning(Errors::Generator, st, tr("ELSIF statement in WHILE statement not supported") );
}

void CppGen::emitRepeatStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_RepeatStatement && st->d_children.size() == 4 &&
            st->d_children[1]->d_tok.d_type == SynTree::R_StatementSequence &&
              st->d_children[3]->d_tok.d_type == SynTree::R_expression );

    out << ws(level) << "do " << endl;
    out << ws(level) << "{" << endl;
    SynTree* stats = st->d_children[1];
    emitStatementSeq(ds, stats->d_children, out, level + 1);
    out << ws(level) << "} while( !( ";
    emitExpression(ds,st->d_children[3],out,level);
    out << " ) );" << endl;
}

void CppGen::emitForStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_ForStatement && st->d_children.size() >= 9 &&
            st->d_children[1]->d_tok.d_type == Tok_ident );
    out << ws(level) << "for( " << st->d_children[1]->d_tok.d_val << " = ";
    emitExpression(ds,st->d_children[3],out,level);
    out << "; ";
    if( st->d_children[6]->d_tok.d_type == Tok_BY )
    {
        // support for both inc > 0 and inc < 0
        emitExpression(ds,st->d_children[7],out,level);
        out << " > 0 ? ";
        out << st->d_children[1]->d_tok.d_val << " <= ";
        emitExpression(ds,st->d_children[5],out,level);
        out << " : ";
        out << st->d_children[1]->d_tok.d_val << " >= ";
        emitExpression(ds,st->d_children[5],out,level);
    }else
    {
        out << st->d_children[1]->d_tok.d_val << " <= ";
        emitExpression(ds,st->d_children[5],out,level);
    }
    out << "; " << st->d_children[1]->d_tok.d_val;
    if( st->d_children[6]->d_tok.d_type == Tok_BY )
    {
        out << " += ";
        emitExpression(ds,st->d_children[7],out,level);
    }else
        out << "++";
    out << " )" << endl;
    SynTree* stat = CodeModel::findFirstChild( st, SynTree::R_StatementSequence, 6 );
    Q_ASSERT( stat != 0 );
    if( stat->d_children.size() > 1 )
        out << ws(level) << "{" << endl;
    emitStatementSeq(ds, stat->d_children, out, level + 1);
    if( stat->d_children.size() > 1 )
        out << ws(level) << "}" << endl;
}

void CppGen::emitCaseStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_CaseStatement && st->d_children.size() >= 5 &&
            st->d_children[1]->d_tok.d_type == SynTree::R_expression );

    const CodeModel::Type* et = d_mdl->typeOfExpression(ds, st->d_children[1] )->deref();
    Q_ASSERT( et != 0 );

    if( et->d_kind == CodeModel::Type::Pointer || et->d_kind == CodeModel::Type::Record )
    {
        // emit typecase
        out << ws(level);

        int n = 0;
        for( int i = 3; i < st->d_children.size() - 1; i++, n++ )
        {
            SynTree* cas = st->d_children[i];
            if( cas->d_tok.d_type != SynTree::R_Case || cas->d_children.isEmpty() )
                continue;
            Q_ASSERT( cas->d_children.size() == 2 );
            SynTree* cll = cas->d_children.first();
            SynTree* seq = cas->d_children.last();
            if( n == 0 )
                out << "if( ";
            else
                out << "else if( ";

            Q_ASSERT( cll->d_children.size() == 1 );
            SynTree* lr = cll->d_children.first();
            Q_ASSERT( lr->d_tok.d_type == SynTree::R_LabelRange );
            Q_ASSERT( lr->d_children.size() == 1 );

            SynTree* qst = CodeModel::flatten(lr->d_children.first(),SynTree::R_qualident);
            Q_ASSERT( qst->d_tok.d_type == SynTree::R_qualident );
            CodeModel::Quali quali = d_mdl->derefQualident(ds,qst);

            out << "dynamic_cast<";
            emitLabel(ds, lr->d_children.first(), out, level );
            out << ">(";
            emitExpression( ds, st->d_children[1], out, level );
            out << ") != 0 ";
            out << " ){" << endl;

            SynTree* id = CodeModel::flatten(st->d_children[1]);
            const CodeModel::NamedThing* var = 0;
            Q_ASSERT( id->d_tok.d_type == Tok_ident );
            var = ds->findByName( id->d_tok.d_val );
            Q_ASSERT( var != 0 );

            CodeModel::Unit scope;
            scope.d_outer = const_cast<CodeModel::Unit*>(ds);
            CodeModel::TypeAlias alias;
            alias.d_name = id->d_tok.d_val;
            alias.d_newType = dynamic_cast<const CodeModel::Type*>( quali.second.first );
            alias.d_alias = const_cast<CodeModel::NamedThing*>(var);
            scope.addToScope(&alias);

            emitStatementSeq( &scope, seq->d_children, out, level+1 );

            out << ws(level) << "} ";
        }
        out << endl;
    }else
    {
        // emit normal case

        // TODO: not yet tested
        const QByteArray name = "__tmp" + QByteArray::number(d_nameNr++);

        emitType( ds, et, out, level );
        out << " " << name << " = ";
        emitExpression( ds, st->d_children[1], out, level );
        out << ";" << endl;
        qDebug() << ds->d_id->d_tok.d_sourcePath;
        out << ws(level);

        int n = 0;
        for( int i = 3; i < st->d_children.size() - 1; i++, n++ )
        {
            SynTree* cas = st->d_children[i];
            if( cas->d_tok.d_type != SynTree::R_Case || cas->d_children.isEmpty() )
                continue;
            Q_ASSERT( cas->d_children.size() == 2 );
            SynTree* cll = cas->d_children.first();
            SynTree* seq = cas->d_children.last();
            if( n == 0 )
                out << "if( ";
            else
                out << "else if( ";

            for( int j = 0; j < cll->d_children.size(); j++ )
            {
                SynTree* lr = cll->d_children[j];
                Q_ASSERT( lr->d_tok.d_type == SynTree::R_LabelRange );
                if( j != 0 )
                    out << " || ";
                if( lr->d_children.size() == 1 )
                {
                    out << name << " == ";
                    emitLabel(ds, lr->d_children.first(), out, level );
                }else if( lr->d_children.size() == 3 )
                {
                    out << name << " >= ";
                    emitLabel(ds, lr->d_children.first(), out, level );
                    out << " && ";
                    out << name << " <= ";
                    emitLabel(ds, lr->d_children.last(), out, level );
                }else
                    Q_ASSERT( false );
            }
            out << " ){" << endl;

            emitStatementSeq(ds, seq->d_children, out, level+1 );

            out << ws(level) << "} ";
        }
        out << endl;
    }

}

void CppGen::emitSet(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st->d_tok.d_type == SynTree::R_set && st->d_children.size() >= 2 );
    out << "( _Set() ";

    for( int i = 1; i < st->d_children.size() - 1; i++ ) // TODO it was -2, but likely wrong, corrected to -1
    {
        SynTree* el = st->d_children[i];
        Q_ASSERT( el->d_tok.d_type == SynTree::R_element && !el->d_children.isEmpty() );
        out << "+ ";
        if( el->d_children.size() == 1 )
        {
            out << "(";
            emitExpression(ds, el->d_children.first(), out, level );
            out << ") ";
        }else
        {
            out << "_Set( ";
            emitExpression(ds, el->d_children.first(), out, level );
            out << ", ";
            emitExpression(ds, el->d_children.last(), out, level );
            out << ") ";
        }
    }
    out << ")";
}

void CppGen::emitScopedName(const CodeModel::Unit* ds, const CodeModel::NamedThing* nt, QTextStream& out)
{
    if( nt->d_scope != ds )
    {
        if( nt->d_scope )
            out << escape(nt->d_scope->d_name);
        else
            out << "???";
        out << "::";
    }
    out << escape(nt->d_name);
}

void CppGen::emitComment(const SynTree* st, QTextStream& out, int level )
{
    if( st == 0 )
        return;

    while( d_nextCmt < d_cmts.size() && d_cmts[d_nextCmt].d_lineNr <= st->d_tok.d_lineNr )
    {
        const QByteArray str = d_cmts[d_nextCmt++].d_val;
        out << ws(level) << "/* " << str.mid(2,str.size()-4) << " */" << endl;
    }
}

void CppGen::emitLabel(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st->d_tok.d_type == SynTree::R_label && st->d_children.size() == 1 );

    SynTree* first = st->d_children.first();
    switch( first->d_tok.d_type )
    {
    case Tok_integer:
        out << first->d_tok.d_val;
        break;
    case Tok_string:
        if( first->d_tok.d_val.size() == 3 )
            out << "'" << ( first->d_tok.d_val[1] == '\'' ? "\\" : "" ) << first->d_tok.d_val[1] << "'"; // CHAR
        else
            out << first->d_tok.d_val;
        break;
    case Tok_hexchar:
        out << "0x" << first->d_tok.d_val.left(first->d_tok.d_val.size() - 1 );
        break;
    case Tok_hexstring:
        out << "\"" << first->d_tok.d_val << "\"";
        break;
    case SynTree::R_qualident:
        out << quali(first);
        break;
    case SynTree::R_expression:
        emitExpression(ds, first, out, level );
        break;
    default:
        out << "/* ERROR unexpected token: " << SynTree::rToStr(first->d_tok.d_type) << " */";
        break;
    }
}

bool CppGen::isSimpleType(const CodeModel::Type* orig)
{
    const CodeModel::Type* b = derefed(orig);
    if( b )
    {
        if( b->isBasicType() && b->d_kind != CodeModel::Type::STRING && b->d_kind != CodeModel::Type::SET )
            return true;
        else if( b->d_kind == CodeModel::Type::Array )
            return false;
        else if( b->d_kind == CodeModel::Type::Record )
            return false;
        else if( b->d_kind == CodeModel::Type::Pointer )
            return true;
        else if( b->d_kind == CodeModel::Type::ProcRef )
            return true;
        else
            return true;
    }
    return true;
}

QByteArray CppGen::escape(const QByteArray& id)
{
    if( isCppKeyword(id) )
        return id + "_";
    else
        return id;
}

void CppGen::emitTerm(const CodeModel::Unit* ds,const SynTree* st, QTextStream& out, int level )
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_term && !st->d_children.isEmpty() );
    if( st->d_children.size() == 1 )
        emitFactor(ds,st->d_children.first(),out,level);
    else
        emitTerm( ds, st->d_children, st->d_children.size() - 1, out, level );
}

void CppGen::emitTerm(const CodeModel::Unit* ds, const QList<SynTree*> st, int i, QTextStream& out, int level)
{
    if( i < 0 )
        return;
    if( i == 0 )
    {
        emitFactor(ds,st[i],out,level);
        return;
    }
    Q_ASSERT( i >= 2 && i < st.size() );

    // a * b * c * d
    // ( ( ( a * b ) * c ) * d )

    SynTree* op = CodeModel::flatten( st[i-1] );

    if( op->d_tok.d_type == Tok_DIV || op->d_tok.d_type == Tok_MOD )
    {
        if( op->d_tok.d_type == Tok_DIV )
            out << "DIV(";
        else
            out << "MOD(";
        emitTerm(ds, st, i - 2, out, level );
        out << ",";
        emitFactor(ds,st[i],out,level);
        out << ")";
    }else
    {
        emitTerm(ds, st, i - 2, out, level );
        switch( op->d_tok.d_type )
        {
        case Tok_Star:
            out << " * ";
            break;
        case Tok_Slash:
            out << " / ";
            break;
        case Tok_Amp:
            out << " && ";
            break;
        default:
            out << " ?? ";
            break;
        }
        emitFactor(ds,st[i],out,level);
    }
}

void CppGen::emitSimpleExpression(const CodeModel::Unit* ds,const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_SimpleExpression && !st->d_children.isEmpty() );
    int i = 0;
    if( st->d_children[i]->d_tok.d_type == Tok_Plus || st->d_children[i]->d_tok.d_type == Tok_Minus )
    {
        out << tokenTypeString(st->d_children[i]->d_tok.d_type);
        i++;
    }
    emitTerm(ds,st->d_children[i++],out,level);
    while( i < st->d_children.size() )
    {
        SynTree* op = CodeModel::flatten( st->d_children[i++] );
        switch( op->d_tok.d_type )
        {
        case Tok_Plus:
            out << " + ";
            break;
        case Tok_Minus:
            out << " - ";
            break;
        case Tok_OR:
            out << " || ";
            break;
        default:
            out << " ?? ";
            break;
        }
        Q_ASSERT( i < st->d_children.size() );
        emitTerm(ds,st->d_children[i++],out,level);
    }
}

void CppGen::emitExpression(const CodeModel::Unit* ds,const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && !st->d_children.isEmpty() );

    SynTree* op = 0;

    if( st->d_children.size() > 1 )
        op = CodeModel::flatten( st->d_children[1] );

    if( op && op->d_tok.d_type == Tok_IS )
    {
        Q_ASSERT( st->d_children.size() == 3 );
        SynTree* q = d_mdl->flatten(st->d_children[2],SynTree::R_qualident);
        out << "dynamic_cast<" << quali(q) << ">(";
        emitSimpleExpression(ds,st->d_children.first(),out,level);
        out << ") != 0 ";
    }else if( op && op->d_tok.d_type == Tok_IN )
    {
        Q_ASSERT( st->d_children.size() == 3 );
        emitSimpleExpression(ds,st->d_children.last(),out,level);
        out << ".contains( ";
        emitSimpleExpression(ds,st->d_children.first(),out,level);
        out << " )";
    }else
    {
        emitSimpleExpression(ds,st->d_children.first(),out,level);
        if( st->d_children.size() > 1 )
        {
            switch( op->d_tok.d_type )
            {
            case Tok_Eq:
                out << " == ";
                break;
            case Tok_Hash:
                out << " != ";
                break;
            case Tok_Lt:
                out << " < ";
                break;
            case Tok_Leq:
                out << " <= ";
                break;
            case Tok_Gt:
                out << " > ";
                break;
            case Tok_Geq:
                out << " >= ";
                break;
            case Tok_IN:
                out << " IN ";
                Q_ASSERT( false ); // wird oben gel√∂st
                break;
            case Tok_IS:
                out << " IS ";
                Q_ASSERT( false ); // wird oben gel√∂st
                break;
            default:
                out << " ?? ";
                break;
            }
            emitSimpleExpression(ds,st->d_children.last(),out,level);
        }
    }
}

